# =======================================================================
# [05G] FUN√á√ÉO DE CATEGORIZA√á√ÉO INDIVIDUAL
# =======================================================================
# Fun√ß√£o para categorizar um √∫nico numero_controle_pncp usando a mesma
# l√≥gica do 05 original, mas de forma isolada e test√°vel.
# =======================================================================

import os
import sys
import time
import json
import math
import psycopg2
from psycopg2.extras import RealDictCursor
from dotenv import load_dotenv
from rich.console import Console

# Configure Rich console
console = Console()

def log_message(message, log_type="info"):
    """Log padronizado"""
    if log_type == "info":
        console.print(f"[white]‚ÑπÔ∏è  {message}[/white]")
    elif log_type == "success":
        console.print(f"[green]‚úÖ {message}[/green]")
    elif log_type == "warning":
        console.print(f"[yellow]‚ö†Ô∏è  {message}[/yellow]")
    elif log_type == "error":
        console.print(f"[red]‚ùå {message}[/red]")
    elif log_type == "debug":
        console.print(f"[cyan]üîß {message}[/cyan]")

# Carregar configura√ß√µes
script_dir = os.path.dirname(os.path.abspath(__file__))
load_dotenv(os.path.join(script_dir, ".env"))

# Configura√ß√µes do banco
DB_CONFIG = {
    'host': os.getenv('SUPABASE_HOST'),
    'database': os.getenv('SUPABASE_DBNAME', 'postgres'),
    'user': os.getenv('SUPABASE_USER'),
    'password': os.getenv('SUPABASE_PASSWORD'),
    'port': os.getenv('SUPABASE_PORT', 5432)
}

# Configura√ß√µes
TOP_K = 5

def create_connection():
    """Cria conex√£o com o banco PostgreSQL/Supabase"""
    try:
        connection = psycopg2.connect(**DB_CONFIG)
        return connection
    except Exception as e:
        log_message(f"Erro ao conectar ao banco: {e}", "error")
        return None

def calculate_confidence(similarities):
    """Calcula o n√≠vel de confian√ßa baseado na diferen√ßa entre as similaridades"""
    if len(similarities) < 2:
        return 0.0
    
    top_score = similarities[0]
    
    if top_score == 0.0:
        return 0.0
    
    # Calcular gaps entre scores
    gaps = [top_score - score for score in similarities[1:]]
    weights = [1/(i+1) for i in range(len(gaps))]
    
    weighted_gap = sum(g * w for g, w in zip(gaps, weights)) / top_score
    confidence = (1 - math.exp(-10 * weighted_gap))
    
    return round(confidence, 4)

def categorize_single_contract(numero_controle_pncp):
    """
    FUN√á√ÉO 05G: Categoriza um √∫nico numero_controle_pncp
    
    Usa exatamente a mesma l√≥gica do 05 original:
    1. Busca o embedding do contrato
    2. Faz busca pgvector nas categorias
    3. Calcula confidence
    4. Atualiza contratacao_emb
    
    Args:
        numero_controle_pncp (str): N√∫mero de controle a ser categorizado
        
    Returns:
        dict: Resultado da categoriza√ß√£o com status, categorias encontradas, etc.
    """
    log_message(f"üéØ Categorizando contrato: {numero_controle_pncp}", "info")
    
    connection = create_connection()
    if not connection:
        return {
            'success': False,
            'error': 'Falha na conex√£o com banco de dados',
            'numero_controle_pncp': numero_controle_pncp
        }
    
    try:
        cursor = connection.cursor(cursor_factory=RealDictCursor)
        
        # PASSO 1: Buscar embedding do contrato
        log_message(f"üìã Buscando embedding para {numero_controle_pncp}...", "debug")
        
        embedding_query = """
        SELECT 
            id_contratacao_emb,
            numero_controle_pncp,
            embeddings
        FROM contratacao_emb 
        WHERE numero_controle_pncp = %s
        AND embeddings IS NOT NULL
        """
        
        cursor.execute(embedding_query, (numero_controle_pncp,))
        embedding_result = cursor.fetchone()
        
        if not embedding_result:
            cursor.close()
            connection.close()
            return {
                'success': False,
                'error': 'Embedding n√£o encontrado para este contrato',
                'numero_controle_pncp': numero_controle_pncp
            }
        
        log_message(f"‚úÖ Embedding encontrado (ID: {embedding_result['id_contratacao_emb']})", "debug")
        
        # PASSO 2: Buscar TOP K categorias usando pgvector (igual ao 05)
        log_message(f"üîç Buscando categorias similares...", "debug")
        
        search_query = """
        SELECT 
            cod_cat,
            nom_cat,
            1 - (cat_embeddings <=> %s::vector) AS similarity
        FROM categoria
        WHERE cat_embeddings IS NOT NULL
        ORDER BY similarity DESC
        LIMIT %s
        """
        
        cursor.execute(search_query, (embedding_result['embeddings'], TOP_K))
        category_results = cursor.fetchall()
        
        if not category_results:
            cursor.close()
            connection.close()
            return {
                'success': False,
                'error': 'Nenhuma categoria encontrada',
                'numero_controle_pncp': numero_controle_pncp
            }
        
        log_message(f"‚úÖ Encontradas {len(category_results)} categorias", "debug")
        
        # PASSO 3: Extrair c√≥digos e similaridades
        top_categories = [row['cod_cat'] for row in category_results]
        top_similarities = [round(float(row['similarity']), 4) for row in category_results]
        
        # PASSO 4: Calcular confian√ßa
        confidence = calculate_confidence(top_similarities)
        
        log_message(f"üìä Melhor categoria: {top_categories[0]} (similaridade: {top_similarities[0]}, confian√ßa: {confidence})", "info")
        
        # PASSO 5: Atualizar contratacao_emb (igual ao 05)
        log_message(f"üíæ Atualizando banco de dados...", "debug")
        
        update_embedding_query = """
            UPDATE contratacao_emb 
            SET 
                top_categories = %s,
                top_similarities = %s,
                confidence = %s
            WHERE id_contratacao_emb = %s
        """
        
        cursor.execute(update_embedding_query, (
            top_categories,
            top_similarities,
            confidence,
            embedding_result['id_contratacao_emb']
        ))
        
        # Commit das altera√ß√µes
        connection.commit()
        cursor.close()
        connection.close()
        
        log_message(f"‚úÖ Contrato {numero_controle_pncp} categorizado com sucesso!", "success")
        
        return {
            'success': True,
            'numero_controle_pncp': numero_controle_pncp,
            'id_contratacao_emb': embedding_result['id_contratacao_emb'],
            'top_categories': top_categories,
            'top_similarities': top_similarities,
            'confidence': confidence,
            'best_category': top_categories[0],
            'best_similarity': top_similarities[0]
        }
        
    except Exception as e:
        log_message(f"‚ùå Erro ao categorizar {numero_controle_pncp}: {e}", "error")
        connection.rollback()
        connection.close()
        return {
            'success': False,
            'error': str(e),
            'numero_controle_pncp': numero_controle_pncp
        }

def get_last_categorization_date():
    """Obt√©m a √∫ltima data de categoriza√ß√£o do system_config"""
    connection = create_connection()
    if not connection:
        return None
    
    try:
        cursor = connection.cursor()
        cursor.execute("""
            SELECT value FROM system_config 
            WHERE key = 'last_categorization_date'
        """)
        result = cursor.fetchone()
        cursor.close()
        connection.close()
        
        if result:
            return result[0]
        else:
            return "20250101"
            
    except Exception as e:
        log_message(f"Erro ao obter √∫ltima data de categoriza√ß√£o: {e}", "error")
        connection.close()
        return "20250101"

def get_first_contract_after_date(date_str):
    """
    Busca o primeiro contrato da data posterior √† last_categorization_date
    para teste da fun√ß√£o 05G
    """
    connection = create_connection()
    if not connection:
        return None
    
    try:
        cursor = connection.cursor()
        
        # Converter data de YYYYMMDD para YYYY-MM-DD e adicionar 1 dia
        from datetime import datetime, timedelta
        date_obj = datetime.strptime(date_str, '%Y%m%d')
        next_date_obj = date_obj + timedelta(days=1)
        next_date_formatted = next_date_obj.strftime('%Y-%m-%d')
        
        log_message(f"üîç Buscando primeiro contrato da data {next_date_obj.strftime('%d/%m/%Y')}...", "info")
        
        # Buscar primeiro contrato da pr√≥xima data
        query = """
        SELECT numero_controle_pncp 
        FROM contratacao 
        WHERE data_publicacao_pncp IS NOT NULL
        AND DATE(data_publicacao_pncp) = %s::date
        LIMIT 1
        """
        
        cursor.execute(query, (next_date_formatted,))
        result = cursor.fetchone()
        cursor.close()
        connection.close()
        
        if result:
            numero_controle = result[0]
            log_message(f"‚úÖ Primeiro contrato encontrado: {numero_controle}", "success")
            return numero_controle
        else:
            log_message(f"‚ö†Ô∏è  Nenhum contrato encontrado na data {next_date_obj.strftime('%d/%m/%Y')}", "warning")
            return None
            
    except Exception as e:
        log_message(f"‚ùå Erro ao buscar primeiro contrato: {e}", "error")
        connection.close()
        return None

if __name__ == "__main__":
    """Teste da fun√ß√£o 05G"""
    
    console.print("\n[bold blue]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold blue]")
    console.print("[bold blue]             üß™ TESTE DA FUN√á√ÉO 05G - CATEGORIZA√á√ÉO INDIVIDUAL      [/bold blue]") 
    console.print("[bold blue]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold blue]\n")
    
    # PASSO 1: Obter √∫ltima data de categoriza√ß√£o
    log_message("üìÖ Obtendo √∫ltima data de categoriza√ß√£o...", "info")
    last_date = get_last_categorization_date()
    log_message(f"√öltima data de categoriza√ß√£o: {last_date}", "info")
    
    # PASSO 2: Buscar primeiro contrato da pr√≥xima data
    first_contract = get_first_contract_after_date(last_date)
    
    if not first_contract:
        log_message("‚ùå N√£o foi poss√≠vel encontrar um contrato para testar", "error")
        sys.exit(1)
    
    # PASSO 3: Testar a fun√ß√£o 05G
    console.print(f"\n[bold yellow]üéØ TESTANDO CATEGORIZA√á√ÉO DO CONTRATO: {first_contract}[/bold yellow]\n")
    
    start_time = time.time()
    result = categorize_single_contract(first_contract)
    end_time = time.time()
    
    # PASSO 4: Exibir resultado
    console.print(f"\n[bold cyan]üìä RESULTADO DA CATEGORIZA√á√ÉO:[/bold cyan]")
    console.print("-" * 60)
    
    if result['success']:
        console.print(f"[green]‚úÖ STATUS: SUCESSO[/green]")
        console.print(f"[white]üìÑ Contrato: {result['numero_controle_pncp']}[/white]")
        console.print(f"[white]üî¢ ID Embedding: {result['id_contratacao_emb']}[/white]")
        console.print(f"[white]üèÜ Melhor Categoria: {result['best_category']}[/white]")
        console.print(f"[white]üìà Similaridade: {result['best_similarity']:.4f}[/white]")
        console.print(f"[white]üéØ Confian√ßa: {result['confidence']:.4f}[/white]")
        console.print(f"[white]‚è±Ô∏è  Tempo: {end_time - start_time:.2f}s[/white]")
        
        console.print(f"\n[cyan]üîù TOP {len(result['top_categories'])} CATEGORIAS:[/cyan]")
        for i, (cat, sim) in enumerate(zip(result['top_categories'], result['top_similarities'])):
            console.print(f"[white]  {i+1}. {cat} - {sim:.4f}[/white]")
            
    else:
        console.print(f"[red]‚ùå STATUS: ERRO[/red]")
        console.print(f"[red]üìÑ Contrato: {result['numero_controle_pncp']}[/red]")
        console.print(f"[red]‚ö†Ô∏è  Erro: {result['error']}[/red]")
    
    console.print("\n[bold blue]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold blue]")
    console.print("[bold blue]                         üèÅ TESTE CONCLU√çDO                        [/bold blue]")
    console.print("[bold blue]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold blue]\n")
