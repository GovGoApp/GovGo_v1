#!/usr/bin/env python3
"""
Analisador Financeiro Autom√°tico
Integra o conversor universal com assistente OpenAI para an√°lise completa de DRE

Fluxo:
1. Recebe arquivo Excel do Zoho
2. Converte para Markdown usando universal_converter
3. Envia para assistente OpenAI especializado em DRE
4. Salva an√°lise na mesma pasta do arquivo original
"""

import os
import sys
from pathlib import Path
from typing import Optional, Tuple
import argparse
from datetime import datetime

# Importar OpenAI
try:
    from openai import OpenAI
except ImportError:
    print("‚ùå Erro: Biblioteca OpenAI n√£o instalada")
    print("üí° Execute: pip install openai")
    sys.exit(1)

# Importar o conversor universal
try:
    from universal_converter import UniversalToMarkdownConverter
except ImportError:
    print("‚ùå Erro: universal_converter.py n√£o encontrado")
    print("üí° Certifique-se de que o arquivo est√° na mesma pasta")
    sys.exit(1)

class FinancialAnalyzer:
    """Analisador financeiro autom√°tico com IA"""
    
    def __init__(self, env_file: str = "openai.env"):
        """
        Inicializa o analisador
        
        Args:
            env_file: Arquivo com configura√ß√µes OpenAI
        """
        self.assistant_id = "asst_G8pkl29kFjPbAhYlS2kAclsU"
        self.client = None
        self.converter = UniversalToMarkdownConverter(decimal_places=4)
        
        # Carregar configura√ß√µes OpenAI
        self._load_openai_config(env_file)
    
    def _load_openai_config(self, env_file: str):
        """Carrega configura√ß√µes OpenAI do arquivo .env"""
        try:
            env_path = Path(__file__).parent / env_file
            
            if not env_path.exists():
                raise FileNotFoundError(f"Arquivo {env_file} n√£o encontrado")
            
            # Ler chave da API
            with open(env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.startswith('api_key='):
                        api_key = line.split('=', 1)[1].strip()
                        break
                else:
                    raise ValueError("api_key n√£o encontrada no arquivo .env")
            
            # Inicializar cliente OpenAI
            self.client = OpenAI(api_key=api_key)
            print("‚úÖ Cliente OpenAI inicializado com sucesso")
            
            # Verificar se o assistente existe
            self._verify_assistant()
            
        except Exception as e:
            print(f"‚ùå Erro ao carregar configura√ß√µes OpenAI: {e}")
            sys.exit(1)
    
    def _verify_assistant(self):
        """Verifica se o assistente existe e est√° acess√≠vel"""
        try:
            assistant = self.client.beta.assistants.retrieve(self.assistant_id)
            print(f"‚úÖ Assistente verificado: {assistant.name}")
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Aviso: N√£o foi poss√≠vel verificar assistente {self.assistant_id}: {e}")
            print("üí° Continuando mesmo assim...")
            return False
    
    def convert_to_markdown(self, excel_file: str) -> str:
        """
        Converte arquivo Excel para Markdown
        
        Args:
            excel_file: Caminho do arquivo Excel
            
        Returns:
            Caminho do arquivo Markdown gerado
        """
        print("üîÑ ETAPA 1: Convertendo Excel para Markdown")
        print("=" * 60)
        
        try:
            # Verificar se arquivo existe
            if not os.path.exists(excel_file):
                raise FileNotFoundError(f"Arquivo n√£o encontrado: {excel_file}")
            
            # Converter usando o conversor universal
            md_file = self.converter.convert_file_to_markdown(excel_file)
            
            print(f"‚úÖ Convers√£o conclu√≠da: {md_file}")
            return md_file
            
        except Exception as e:
            print(f"‚ùå Erro na convers√£o: {e}")
            raise
    
    def upload_file_to_openai(self, file_path: str) -> str:
        """
        Faz upload do arquivo para OpenAI
        
        Args:
            file_path: Caminho do arquivo
            
        Returns:
            ID do arquivo no OpenAI
        """
        print("üì§ ETAPA 2: Upload do arquivo para OpenAI")
        print("=" * 60)
        
        try:
            with open(file_path, 'rb') as f:
                file_obj = self.client.files.create(
                    file=f,
                    purpose='assistants'
                )
            
            print(f"‚úÖ Arquivo enviado - ID: {file_obj.id}")
            
            # Aguardar um pouco para processamento
            import time
            time.sleep(5)
            
            return file_obj.id
            
        except Exception as e:
            print(f"‚ùå Erro no upload: {e}")
            raise
    
    def create_thread_and_run(self, file_id: str, prompt: str = None) -> str:
        """
        Cria thread e executa an√°lise com o assistente
        
        Args:
            file_id: ID do arquivo no OpenAI
            prompt: Prompt personalizado (opcional)
            
        Returns:
            Resposta do assistente
        """
        print("ü§ñ ETAPA 3: An√°lise com Assistente IA")
        print("=" * 60)
        
        if not prompt:
            prompt = "An√°lise focada em 1) varia√ß√£o das grande contas cont√°beis ao longo do ano e 2) varia√ß√µes cr√≠ticas das contas cont√°beis entre os dois √∫ltimos meses"

        try:
            # Criar thread
            thread = self.client.beta.threads.create(
                messages=[
                    {
                        "role": "user",
                        "content": prompt,
                        "attachments": [
                            {
                                "file_id": file_id,
                                "tools": [{"type": "file_search"}]
                            }
                        ]
                    }
                ]
            )
            
            print(f"üìù Thread criada: {thread.id}")
            
            # Executar assistente
            run = self.client.beta.threads.runs.create(
                thread_id=thread.id,
                assistant_id=self.assistant_id
            )
            
            print(f"üöÄ Execu√ß√£o iniciada: {run.id}")
            
            # Aguardar conclus√£o com timeout
            print("‚è≥ Aguardando an√°lise...")
            max_wait_time = 300  # 5 minutos m√°ximo
            wait_time = 0
            check_interval = 3   # Verificar a cada 3 segundos
            
            import time
            while wait_time < max_wait_time:
                try:
                    run_status = self.client.beta.threads.runs.retrieve(
                        thread_id=thread.id,
                        run_id=run.id
                    )
                    
                    # Log menos frequente para evitar spam
                    if wait_time % 15 == 0:  # Log a cada 15 segundos
                        elapsed_min = wait_time // 60
                        elapsed_sec = wait_time % 60
                        print(f"üìä Status: {run_status.status} (tempo: {elapsed_min}m{elapsed_sec}s)")
                    
                    if run_status.status == 'completed':
                        break
                    elif run_status.status in ['failed', 'cancelled', 'expired']:
                        error_msg = f"Execu√ß√£o falhou: {run_status.status}"
                        if hasattr(run_status, 'last_error') and run_status.last_error:
                            error_msg += f" - {run_status.last_error}"
                        print(f"‚ùå {error_msg}")
                        # Aguardar mais um pouco e tentar novamente
                        print("üîÑ Aguardando mais tempo...")
                        time.sleep(10)
                        continue
                    elif run_status.status == 'requires_action':
                        print("‚ö†Ô∏è Assistente requer a√ß√£o - verificando...")
                        if hasattr(run_status, 'required_action') and run_status.required_action:
                            print(f"üîß A√ß√£o requerida: {run_status.required_action}")
                    
                    time.sleep(check_interval)
                    wait_time += check_interval
                    
                except Exception as api_error:
                    print(f"‚ö†Ô∏è Erro ao verificar status: {api_error}")
                    time.sleep(check_interval)
                    wait_time += check_interval
            
            # Verificar se deu timeout
            if wait_time >= max_wait_time:
                print(f"‚è∞ Timeout ap√≥s {max_wait_time//60} minutos")
                print("üí° Tentando cancelar execu√ß√£o...")
                try:
                    self.client.beta.threads.runs.cancel(thread_id=thread.id, run_id=run.id)
                    print("‚úÖ Execu√ß√£o cancelada")
                except:
                    print("‚ö†Ô∏è N√£o foi poss√≠vel cancelar execu√ß√£o")
                raise Exception(f"Timeout na an√°lise ap√≥s {max_wait_time//60} minutos")
            
            # Obter resposta
            print("üì® Obtendo resposta do assistente...")
            messages = self.client.beta.threads.messages.list(thread_id=thread.id)
            
            # Buscar √∫ltima mensagem do assistente
            response_text = ""
            for message in messages.data:
                if message.role == 'assistant':
                    for content in message.content:
                        if hasattr(content, 'text'):
                            response_text += content.text.value
                    break
            
            if not response_text:
                # Tentar obter √∫ltima mensagem independente do role
                print("‚ö†Ô∏è Nenhuma resposta do assistente encontrada, verificando todas as mensagens...")
                for message in messages.data:
                    print(f"üìß Mensagem de {message.role}: {len(str(message.content))} chars")
                    if len(str(message.content)) > 100:  # Pegar mensagem mais substancial
                        for content in message.content:
                            if hasattr(content, 'text'):
                                response_text += content.text.value
                        break
            
            if not response_text:
                raise Exception("Nenhuma resposta encontrada do assistente")
            
            print("‚úÖ An√°lise conclu√≠da!")
            print(f"üìè Tamanho da resposta: {len(response_text)} caracteres")
            return response_text
            
        except Exception as e:
            print(f"‚ùå Erro na an√°lise: {e}")
            # Log adicional para debug
            import traceback
            print("üîç Detalhes do erro:")
            traceback.print_exc()
            raise
    
    def save_analysis(self, analysis: str, original_file: str) -> str:
        """
        Salva a an√°lise na mesma pasta do arquivo original
        
        Args:
            analysis: Texto da an√°lise
            original_file: Arquivo original para determinar pasta
            
        Returns:
            Caminho do arquivo de an√°lise salvo
        """
        print("üíæ ETAPA 4: Salvando an√°lise")
        print("=" * 60)
        
        try:
            # Determinar pasta e nome do arquivo
            original_path = Path(original_file)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            analysis_file = original_path.parent / f"{original_path.stem}_ANALISE_{timestamp}.md"
            
            # Criar cabe√ßalho da an√°lise
            header = f"""# üìä AN√ÅLISE FINANCEIRA AUTOM√ÅTICA

**Arquivo Original:** {original_path.name}
**Data da An√°lise:** {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}
**Assistente IA:** {self.assistant_id}

---

"""
            
            # Salvar an√°lise
            with open(analysis_file, 'w', encoding='utf-8') as f:
                f.write(header + analysis)
            
            print(f"‚úÖ An√°lise salva: {analysis_file}")
            return str(analysis_file)
            
        except Exception as e:
            print(f"‚ùå Erro ao salvar an√°lise: {e}")
            raise
    
    def cleanup_openai_file(self, file_id: str):
        """Remove arquivo do OpenAI ap√≥s an√°lise"""
        try:
            self.client.files.delete(file_id)
            print(f"üóëÔ∏è Arquivo removido do OpenAI: {file_id}")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao remover arquivo: {e}")
    
    def create_emergency_analysis(self, md_file_path: str) -> str:
        """
        Cria an√°lise b√°sica como fallback quando o assistente falha
        
        Args:
            md_file_path: Caminho do arquivo MD
            
        Returns:
            An√°lise b√°sica do arquivo
        """
        print("üö® Criando an√°lise de emerg√™ncia...")
        
        try:
            # Ler arquivo MD
            with open(md_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # An√°lise b√°sica
            lines = content.split('\n')
            total_lines = len(lines)
            
            analysis = f"""# üö® AN√ÅLISE DE EMERG√äNCIA

‚ö†Ô∏è **NOTA**: Esta √© uma an√°lise b√°sica gerada automaticamente porque o assistente IA n√£o respondeu a tempo.

## üìÑ INFORMA√á√ïES DO ARQUIVO

- **Tamanho**: {len(content):,} caracteres
- **Linhas**: {total_lines:,}
- **Arquivo MD**: {md_file_path}

## üîç AN√ÅLISE B√ÅSICA

O arquivo foi convertido com sucesso para Markdown, mas a an√°lise detalhada do assistente IA falhou.

### Pr√≥ximos passos recomendados:

1. **Verificar conectividade**: Tente novamente em alguns minutos
2. **Arquivo manual**: Abra o arquivo MD gerado para an√°lise manual
3. **Assistente alternativo**: Use outro m√©todo de an√°lise
4. **Suporte t√©cnico**: Entre em contato se o problema persistir

## üìä ARQUIVO GERADO

O arquivo Markdown foi gerado com sucesso e cont√©m os dados convertidos do Excel original.
Voc√™ pode abrir este arquivo em qualquer editor de texto ou visualizador Markdown.

### Como proceder:

1. Abra o arquivo MD gerado
2. Localize as se√ß√µes de grupos cont√°beis
3. Identifique manualmente as varia√ß√µes cr√≠ticas
4. Calcule os indicadores principais (CMV%, Pessoal%, Admin%)

"""
            return analysis
            
        except Exception as e:
            return f"""# üö® AN√ÅLISE DE EMERG√äNCIA - ERRO

N√£o foi poss√≠vel gerar nem mesmo uma an√°lise b√°sica.

**Erro**: {e}

**Arquivo MD**: {md_file_path}

Por favor, verifique o arquivo manualmente.
"""
    
    def analyze_financial_report(self, excel_file: str, custom_prompt: str = None, cleanup: bool = True) -> Tuple[str, str]:
        """
        Processo completo: convers√£o + an√°lise + salvamento
        
        Args:
            excel_file: Arquivo Excel do Zoho
            custom_prompt: Prompt personalizado (opcional)
            cleanup: Se deve limpar arquivo do OpenAI (padr√£o: True)
            
        Returns:
            Tupla com (caminho_markdown, caminho_analise)
        """
        print("üéØ INICIANDO AN√ÅLISE FINANCEIRA AUTOM√ÅTICA")
        print("=" * 80)
        print(f"üìÅ Arquivo: {excel_file}")
        print(f"ü§ñ Assistente: {self.assistant_id}")
        print("=" * 80)
        
        md_file = None
        file_id = None
        analysis = None
        
        try:
            # 1. Converter para Markdown
            md_file = self.convert_to_markdown(excel_file)
            
            # 2. Upload para OpenAI
            file_id = self.upload_file_to_openai(md_file)
            
            # 3. An√°lise com IA
            analysis = self.create_thread_and_run(file_id, custom_prompt)
            
            # 4. Salvar an√°lise
            analysis_file = self.save_analysis(analysis, excel_file)
            
            # 5. Limpeza (opcional)
            if cleanup and file_id:
                self.cleanup_openai_file(file_id)
            
            print("\n" + "=" * 80)
            print("üéâ AN√ÅLISE CONCLU√çDA COM SUCESSO!")
            print("=" * 80)
            print(f"üìÑ Markdown: {md_file}")
            print(f"üìä An√°lise: {analysis_file}")
            
            return md_file, analysis_file
            
        except Exception as e:
            print(f"\n‚ùå ERRO NA AN√ÅLISE: {e}")
            
            # Tentar limpeza em caso de erro
            if cleanup and file_id:
                try:
                    self.cleanup_openai_file(file_id)
                except:
                    pass
            
            raise

def parse_arguments():
    """Parse argumentos da linha de comando"""
    parser = argparse.ArgumentParser(
        description="Analisador Financeiro Autom√°tico - Excel ‚Üí Markdown ‚Üí An√°lise IA",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos de uso:

  # An√°lise b√°sica
  python financial_analyzer.py relatorio.xlsx
  
  # Com prompt personalizado
  python financial_analyzer.py relatorio.xlsx --prompt "Foque apenas no CMV e pessoal"
  
  # Manter arquivo no OpenAI (n√£o limpar)
  python financial_analyzer.py relatorio.xlsx --no-cleanup
  
  # Especificar arquivo de configura√ß√£o
  python financial_analyzer.py relatorio.xlsx --env custom.env

Arquivos gerados:
- ARQUIVO_dec4_YYYYMMDD_HHMMSS.md (Markdown convertido)
- ARQUIVO_ANALISE_YYYYMMDD_HHMMSS.md (An√°lise IA)
        """
    )
    
    parser.add_argument(
        'excel_file',
        help='Arquivo Excel do Zoho para an√°lise'
    )
    
    parser.add_argument(
        '--prompt',
        help='Prompt personalizado para o assistente'
    )
    
    parser.add_argument(
        '--env',
        default='openai.env',
        help='Arquivo de configura√ß√£o OpenAI (padr√£o: openai.env)'
    )
    
    parser.add_argument(
        '--no-cleanup',
        action='store_true',
        help='N√£o remover arquivo do OpenAI ap√≥s an√°lise'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='Analisador Financeiro Autom√°tico v1.0'
    )
    
    return parser.parse_args()

def main():
    """Fun√ß√£o principal"""
    args = parse_arguments()
    
    try:
        # Verificar se arquivo existe
        if not os.path.exists(args.excel_file):
            print(f"‚ùå Arquivo n√£o encontrado: {args.excel_file}")
            return
        
        # Verificar se √© arquivo Excel
        if not args.excel_file.lower().endswith(('.xlsx', '.xls')):
            print(f"‚ùå Arquivo deve ser Excel (.xlsx ou .xls): {args.excel_file}")
            return
        
        # Criar analisador
        analyzer = FinancialAnalyzer(env_file=args.env)
        
        # Executar an√°lise completa
        md_file, analysis_file = analyzer.analyze_financial_report(
            excel_file=args.excel_file,
            custom_prompt=args.prompt,
            cleanup=not args.no_cleanup
        )
        
        print(f"\nüéØ ARQUIVOS GERADOS:")
        print(f"üìÑ {md_file}")
        print(f"üìä {analysis_file}")
        
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è An√°lise interrompida pelo usu√°rio")
    except Exception as e:
        print(f"\n‚ùå Erro durante a an√°lise: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    # Se h√° argumentos, usar fun√ß√£o principal
    if len(sys.argv) > 1:
        main()
    else:
        # Exemplo de uso direto
        print("üí° Modo de exemplo - usando arquivo espec√≠fico")
        print("üí° Use --help para ver op√ß√µes de linha de comando")
        
        # Arquivo de exemplo
        example_file = r"C:\Users\Haroldo Duraes\Desktop\Grupo\Relatorios\RESULTADO_ANALITICO_-_MELHOR.xlsx"
        
        if os.path.exists(example_file):
            try:
                analyzer = FinancialAnalyzer()
                md_file, analysis_file = analyzer.analyze_financial_report(example_file)
                print(f"\nüéØ An√°lise de exemplo conclu√≠da!")
                print(f"üìÑ {md_file}")
                print(f"üìä {analysis_file}")
            except Exception as e:
                print(f"‚ùå Erro na an√°lise de exemplo: {e}")
        else:
            print(f"‚ùå Arquivo de exemplo n√£o encontrado: {example_file}")
            print("üí° Execute com: python financial_analyzer.py seu_arquivo.xlsx")
